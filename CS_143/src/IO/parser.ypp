/* Parses records containing a number and zero or more subrecords */
%{
#include <stdint.h>
#include <FlexLexer.h>
#include <string>
#include <vector>
#include <string>
#include <memory>
#include <map>
#include <iostream>
//#include "../EventHandling/Packet.h"
//#include "../EventHandling/Event.h"
//#include "../EventHandling/UnackEvent.h"
//#include "../EventHandling/FlowEvent.h"
#include "../EventGenerators/Flow.h"
//#include "../EventHandling/PacketEvent.h"
#include "../EventGenerators/EventGenerator.h"
#include "../EventGenerators/FlowGenerator.h"
#include "../EventGenerators/Router.h"
#include "../EventGenerators/Host.h"
#include "../EventGenerators/Link.h"
#include "../EventHandling/Handler.h"
//#include "../EventGenerators/CongestionAlg.h"
#include "../EventGenerators/TCPReno.h"
#include "../EventGenerators/TCPVegas.h"
#include "NetInput.h"


int yyerror(const char *s);
int yylex();

// map for link lookups
std::map<std::string, std::shared_ptr<Link> > link_map;
// map for host lookups
std::map<std::string, std::shared_ptr<Host> > host_map;
// lists for accumulating strings
static std::vector<std::string> str_list; 
static std::vector<std::string> old_str_list; 
// handler
static Handler h;
%}

%union {
    char* strval;
    float fval;
}

%defines
%token <fval> FLOAT
%token <strval> STR
%token HOSTTOK
%token ROUTERTOK
%token LINKTOK
%token FLOWTOK
%token LBRACK
%token RBRACK

%%

commands: command | command commands; //| commands command;
command:  host | router | link | flow;

close: RBRACK
open:  LBRACK {
  //std::cout << "Opening a list" << std::endl;
  old_str_list = str_list;
  str_list.clear();
};

strings: string | string strings;
string: STR {
  //std::cout << $1 << std::endl;
  str_list.push_back($1);
};

list: open strings close {
  std::cout << "LIST: ";
  for (auto &it : str_list)
    std::cout << it << ", ";
  std::cout << std::endl;
};

// Host(shared_ptr<Link> host_link, 
//      string host_id)
host: HOSTTOK STR STR {
  //std::cout << "HOST: " << $2 << ' ' << $3 << std::endl;
  // create host
  auto host = std::make_shared<Host>(link_map[$2], $3);
  // add host to local map
  host_map[$3] = host;
  // add link to handler
  h.addGenerator(host);	
};

// Router(vector<string> host_list, 
//        vector<shared_ptr<Link> > neighboring_links, 
//        string router_id)
router: ROUTERTOK list list STR {
  //std::cout << "ROUTER: " << $4 << std::endl;
  // construct string vector from host_list
  std::vector<std::string> host_list = old_str_list; // copied???
  // construct shared_ptr<Link> vector from neighboring_links
  std::vector<std::shared_ptr<Link> > neighboring_links;
  for (auto &it : str_list) {
    neighboring_links.push_back(link_map[it]);
  }
  // make router
  auto router = std::make_shared<Router>(host_list, neighboring_links, $4);
  // give to handler
  h.addGenerator(router);
};

// Link(float buffer_size, 
//      float prop_delay, 
//      float capacity, 
//      string n1, 
//      string n2, 
//      string link_id)
link: LINKTOK FLOAT FLOAT FLOAT STR STR STR {
  //std::cout << "LINK: " << $2 << ' ' << $3 << ' ' << $4 << "..." << std::endl;
  // create link
  auto link = std::make_shared<Link>($2, $3, $4, $5, $6, $7);
  // add link to local map
  link_map[$7] = link;
  // add link to handler
  h.addGenerator(link);
};

// Flow(string ID, 
//      string dest, 
//      shared_ptr<CongestionAlg> alg, 
//      int data_size, 
//      shared_ptr<Host> host, 
//      int windowSize, 
//      float timestamp)
flow: FLOWTOK STR STR STR FLOAT STR FLOAT FLOAT {
  //std::cout << "FLOW: " << $5 << ' ' << $7 << ' ' << $8 << std::endl;	
  std::string ID = $2;
  std::string dest = $3;
  //std::shared_ptr<CongestionAlg> alg;
  std::shared_ptr<CongestionAlg> alg = std::make_shared<TCPVegas>();
  //if ($4 == "VEGAS") {
  //  alg = std::make_shared<TCPVegas>();
  //} else {
  //  alg = std::make_shared<TCPReno>();
  //}
  int data_size = (int) $5;
  std::shared_ptr<Host> host = host_map[$6];
  int windowSize = (int) $7;
  int timestamp = $8;
  auto flow = std::make_shared<Flow>(ID, dest, alg, data_size, host, 
                                     windowSize, timestamp);
  std::vector<std::shared_ptr<Flow> > flow_list;
  flow_list.push_back(flow);  
  auto flow_g = std::make_shared<FlowGenerator>(flow_list, "flow_g");

  // give to handler
  h.addGenerator(flow_g);
};

%%

static FlexLexer *lexer;

int yyerror(const char * s) {
   std::cerr << "Parse error: " << s << std::endl;
   return 0;
}

int yylex() {
   return lexer->yylex();
}


//void parse(std::istream &datafile) {
Handler& parse(std::istream &datafile, Handler &h) {
   // Construct the lexer.
   lexer = new yyFlexLexer(&datafile);
   // Run the parser.
   if(yyparse()) {
       std::cerr << "Parse failed!" << std::endl;
       exit(1);
   }

   delete lexer;
   // return handler
   return h;
}
